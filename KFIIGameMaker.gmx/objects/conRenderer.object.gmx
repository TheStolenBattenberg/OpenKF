<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Graphics

//Rendering Stuff
surface = surface_create(conMain.GameConfig[? "renderWidth"], conMain.GameConfig[? "renderHeight"]);

//Screen Tint Values
screenTintR = 1.0;
screenTintG = 0;
screenTintB = 0;
screenTintI = 0;

//PSX VRAM 'Emulation'
psxVram = surface_create(4096, 512);
psxVramTexture = surface_get_texture(psxVram); //Also reaquire a quick texture pointer

psxVramRedraw = false;
psxVramPartialRedraw = false;

psxScrollTex = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Camera

//Camera Position
camXfrom = 0;
camYfrom = 0;
camZfrom = 0;

//Camera LookAt Vector
camXto   = 0;
camYto   = 0;
camZto   = 0;

//Camera Rotation
camXrot  = 0;
camYrot  = 0;
camfX    = 0;

//Camera other
camFOV = 60;
camAspect = conMain.GameConfig[? "renderWidth"] / conMain.GameConfig[? "renderHeight"];
camNear   = 0.01;
camFar    = 1024.0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load some extra textures

texPartFire = TextureLoad(global.FS[1] + "Custom\Fire.dds", 128, 128);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Redraw Textures

//Ensure the PSX VRAM surface exists.
if(!surface_exists(psxVram))
{
    psxVram        = surface_create(4096, 512);
    psxVramTexture = surface_get_texture(psxVram); //Also reaquire a quick texture pointer
    
    psxVramRedraw = true;
}

d3d_end();

if(psxVramRedraw == true)
{
    show_debug_message("Redrawing PSX VRAM...");
    var CT = current_time;
        
    //Setup surface for drawing
    surface_set_target(psxVram);
    d3d_set_projection_ortho(0, 0, surface_get_width(psxVram), surface_get_height(psxVram), 0);
    
    draw_clear(c_white);
    
    var arrTex = null;
    
    //Draw Textures from FDAT
    for(var i = 0; i &lt; array_length_1d(conMain.fdatTexture); ++i)
    {
        arrTex = conMain.fdatTexture[i];
        
        //We apply stretching here... You CAN override with bigger textures, but it will downsample to the original size.
        draw_background_stretched(arrTex[4], arrTex[0], arrTex[1], arrTex[2], arrTex[3]);
    }
    
    //Draw MAP textures
    var GameMap = conMain.gameMap;
    if(GameMap != null)
    {
        //Draw Map Texture Bank #1
        if(GameMap.textureBank1 != null)
        {
            for(var i = 0; i &lt; array_length_1d(GameMap.textureBank1); ++i)
            {
                arrTex = GameMap.textureBank1[i];
                
                //We apply stretching here... You CAN override with bigger textures, but it will downsample to the original size.
                draw_background_stretched(arrTex[4], arrTex[0], arrTex[1], arrTex[2], arrTex[3]);
            }
        }
        
        //Draw Map Texture Bank #2
        if(GameMap.textureBank2 != null)
        {
            for(var i = 0; i &lt; array_length_1d(GameMap.textureBank2); ++i)
            {
                arrTex = GameMap.textureBank2[i];
                
                //We apply stretching here... You CAN override with bigger textures, but it will downsample to the original size.
                draw_background_stretched(arrTex[4], arrTex[0], arrTex[1], arrTex[2], arrTex[3]);
            }
        }
    }
    
    //End surface drawing
    surface_reset_target();
    
    if(debug == true)
    {
        surface_save(psxVram, "vram_out.png");
    }
    
    show_debug_message("DONE! (tt: " + string(current_time-CT)+")");
    
    psxVramRedraw = false;
}

//Just used for trigger RTIM loading...
if(psxVramPartialRedraw)
{
    show_debug_message("Partial VRAM redraw beginning");
    var CT = current_time;
    
    var GameMap = conMain.gameMap;
    
    //Draw MAP textures
    surface_set_target(psxVram);   
    d3d_set_projection_ortho(0, 0, surface_get_width(psxVram), surface_get_height(psxVram), 0);
     
    if(GameMap != null)
    {
        //Draw Map Texture Bank #2
        if(GameMap.textureBank2 != null)
        {
            for(var i = 0; i &lt; array_length_1d(GameMap.textureBank2); ++i)
            {
                arrTex = GameMap.textureBank2[i];
                
                //We apply stretching here... You CAN override with bigger textures, but it will downsample to the original size.
                draw_background_stretched(arrTex[4], arrTex[0], arrTex[1], arrTex[2], arrTex[3]);
            }
        }
    }    
    surface_reset_target();
    
    show_debug_message("DONE! (tt: " + string(current_time-CT)+")");
    
    psxVramPartialRedraw = false;
}

//Draw Scrolling Textures
surface_set_target(psxVram);
for(var i = 0; i &lt; ds_list_size(psxScrollTex); ++i)
{
    //Get scroll data
    var arrSTex = psxScrollTex[| i];
    
    //Get actual texture
    var arrTex  = conMain.fdatTexture[arrSTex[0]];
    
    //Update scroll texture
    var tW = background_get_width(arrTex[4]);
    var tH = background_get_height(arrTex[4]);
    
    arrSTex[@ 3] = (arrSTex[3] + arrSTex[1]) % tW;
    arrSTex[@ 4] = (arrSTex[4] + arrSTex[2]) % tH;
    
    //Draw Scrolling Textures
    var STXA = (arrSTex[@ 3]);
    var STYA = (arrSTex[@ 4]);
    
    //Calculate VRAM draw Location
    var DX = arrTex[0] + arrSTex[5];
    var DY = arrTex[1] + arrSTex[6];
    
    draw_background_part(arrTex[4], 0,       0,       tW-STXA, tH-STYA, DX + arrSTex[@ 3], DY + arrSTex[@ 4]);
    draw_background_part(arrTex[4], tW-STXA, 0,       STXA,    tH-STYA, DX,                DY + arrSTex[@ 4]);       
    draw_background_part(arrTex[4], 0,       tH-STYA, tW-STXA, STYA,    DX + arrSTex[@ 3], DY);
    draw_background_part(arrTex[4], tW-STXA, tH-STYA, STXA,    STYA,    DX,                DY);       
}
surface_reset_target();


if(keyboard_check_pressed(vk_right))
{
    show_debug_message("Debug function in conRenderer, bottom of redraw textures...");
    surface_save(psxVram, "scrolls.png");
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Game

//Make sure surface exists.
if(!surface_exists(surface))
    surface = surface_create(conMain.GameConfig[? "renderWidth"], conMain.GameConfig[? "renderHeight"]);

if(conMain.gameMap == null)
    exit;    
    
//Set surface for rendering
surface_set_target(surface);
draw_clear(c_black);

//Set D3D
d3d_start();

texture_set_stage(0, psxVramTexture);

//Set camera
d3d_set_projection_ext(camXfrom, camYfrom, camZfrom, camXto, camYto, camZto, 0, 1, 0, camFOV, camAspect, camNear, camFar);

//Call draw event for map
with(conMain.gameMap)
    event_perform(ev_other, ev_user0);

if(debug == true)
{
    CollisionWorldDebugDraw(keyboard_check_pressed(ord("9")));
}    
    
//If player exists
if(instance_exists(objPlayer))
{
    //First clear the depth
    draw_clear_depth(500);

    //Set texture (again? wtf dx9)
    texture_set_stage(0, psxVramTexture);
    
    //Draw this shit.
    with(objPlayer)
    {
        event_perform(ev_other, ev_user0);
    }
}

//Unset D3D :)
d3d_end();

//End surface rendering
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
