<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Map Related Enums

enum MapDrawMode {
    Tiled,
    Chunked
};
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Store Object Class Reference

arrObjectClasses = conMain.fdatDB[0];
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///LoadMapData

show_debug_message("Loading map data...");

// Make sure D3D is NOT enabled... Fucking texture bugs, man
d3d_end();

//Load Tileset from file
tileset = FileSystemLoadRTMD(fileTileset, "none", collsetS);
if(tileset == null)
    show_error("Couldn't find tileset ("+fileTileset+")!", true);   

//Load Tilemap from file
MAP1 = MAP1LoadFromBuffer(FileSystemGetBuffer(fileTilemap), FileSystemGetOffset(fileTilemap));
 
if(MAP1 == null)
    show_error("Couldn't find tilemap ("+fileTilemap+")!", true);

tilemap = MAP1[0];
cBuffer = MAP1[1];
    
buffer_save(cBuffer, "Collision.dat");

//Load textureBank1 from file
textureBank1 = FileSystemLoadRTIM(fileTextureMain, "Textures\"+fileTextureMain+"\");
if(textureBank1 == null)
    show_error("Couldn't find texture ("+fileTextureMain+")!", true);
 
//Load database from file
database = MAP2LoadFromBuffer(FileSystemGetBuffer(fileDatabase), FileSystemGetOffset(fileDatabase));
if(database == null)
    show_error("Couldn't find database ("+fileDatabase+")!", true); 

alarm[0] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Free Map Resources

//Set 'ready' flag to false to avoid any nasty errors
ready = false;

//Free Tilemap
show_debug_message("Freeing Tilemap...");
for(var i = 0; i &lt; 80; ++i)
{
    for(var j = 0; j &lt; 80; ++j)
    {
        tilemap[i, j] = -1;
    }
}
tilemap = -1;

//Free Tileset (if loaded)
show_debug_message("Freeing Tileset...");
if(tileset != null)
{
    for(var i = 0; i &lt; array_length_1d(tileset); ++i)
    {
        MSMMeshBuilderFree(tileset[i]);
        tileset[@ i] = -1;
    }
    
    tileset = -1;
}

//Free Collision Stuff
show_debug_message("Freeing Collision Data...");
CollisionWorldRemoveBody(collisionBody1);
CollisionWorldRemoveBody(collisionBody2);
CollisionBodyDestroy(collisionBody2);
CollisionBodyDestroy(collisionBody1);
CollisionShapeDestroy(colChunks[0]);
CollisionShapeDestroy(colChunks[1]);

//Free Opaque Chunks
show_debug_message("Freeing Opaque Chunk Data...");
if(chunks[0] != null)
    MSMFree(chunks[0]);

//Free Translucent Chunks
show_debug_message("Freeing Translucent Chunk Data...");
if(chunks[1] != null)
    MSMFree(chunks[1]);

//Free Database
show_debug_message("Freeing Database...");
var EC = database[0];
var EI = database[1];
var OI = database[2];

for(var i = 0; i &lt; array_length_1d(EC); ++i)
{
    EC[@ i] = -1;
}
database[@ 0] = -1;
EC = -1;
show_debug_message("Entity Class Done...");

for(var i = 0; i &lt; array_length_1d(EI); ++i)
{
    EI[@ i] = -1;
}
database[@ 1] = -1;
EI = -1;
show_debug_message("Entity Declaration Done...");

for(var i = 0; i &lt; array_length_1d(OI); ++i)
{
    var inst = OI[@ i];
    
    inst[@ 9] = -1;    
    OI[@ i] = -1;
}
database[@ 2] = -1;
OI = -1;
show_debug_message("Object Declaration Done...");

//Free Instances
show_debug_message("Freeing Triggers...");
if(triggerInstance != null)
{
    for(var i = 0; i &lt; ds_list_size(triggerInstance); ++i)
        triggerInstance[| i] = -1;
        
    ds_list_clear(triggerInstance);
    ds_list_destroy(triggerInstance);
}

show_debug_message("Freeing Skyboxes");
if(skyboxInstance != null)
{
    for(var i = 0; i &lt; ds_list_size(skyboxInstance); ++i)
        skyboxInstance[| i] = -1;
        
    ds_list_clear(skyboxInstance);
    ds_list_destroy(skyboxInstance);
}

show_debug_message("Freeing Object Instances...");
if(objectInstance != null)
{
    for(var i = 0; i &lt; ds_list_size(objectInstance); ++i)
        ObjectInstanceDestroy(objectInstance[| i]);
    
    ds_list_clear(objectInstance);
    ds_list_destroy(objectInstance);
}

show_debug_message("Freeing Entity Instances...");
if(entityInstance != null)
{
    ds_list_clear(entityInstance);
    ds_list_destroy(entityInstance);
}

show_debug_message("Freeing Effect Instances...");
if(effectInstance != null)
{
    ds_list_clear(effectInstance);
    ds_list_destroy(effectInstance);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Some delayed actions

//Redraw VRAM
conRenderer.psxVramRedraw = true;

//Queue Music
MusicQueueAdd(fileMusic, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Is Map Ready?

if(!ready)
    exit;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Triggers

for(var i = 0; i &lt; ds_list_size(triggerInstance); ++i)
{
    //Get Trigger Instance
    var arrTriggerInstance = triggerInstance[| i];
    
    //Update Trigger
    TriggerInstanceUpdate(arrTriggerInstance);
    
    //What type of trigger is this?
    switch(arrTriggerInstance[3])
    {
        //Load Area Trigger
        case TriggerType.LoadArea:            
            if(TriggerInstanceOnEnter(arrTriggerInstance))
            {      
                //Print Debugging shit
                show_debug_message("Entered Trigger ID: " + string(i));   
                     
                //Get Trigger Flags
                var arrFlags = arrTriggerInstance[12];
                
                if(arrFlags[3] != $FF)
                {
                    //Load Map
                    if(MapIDToObjectID(arrFlags[3]) != conMain.gameMap.object_index)
                    {
                        //Calculate player/target XZ difference
                        var posDeltaX = arrFlags[0] - objPlayer.posX;
                        var posDeltaZ = arrFlags[2] - objPlayer.posZ;
                        
                        //Add delta to player position, set Y
                        objPlayer.posX += posDeltaX;
                        objPlayer.posZ += posDeltaZ;
                        objPlayer.posY = arrFlags[1] + (objPlayer.height / 2)
                        objPlayer.lrSpeed = 0;
                        objPlayer.fbSpeed = 0;
                        
                        //Change Map
                        GameSetMap(MapIDToObjectID(arrFlags[3]));
                        
                        //Exit so no more triggers can be processed.                        
                        exit;
                    }
                }else
                if(arrFlags[3] == $FF)
                {
                    //Load Assets

                    //Textures
                    if(arrFlags[5] != $FF)
                    {
                        //Load new textures
                        textureBank2 = FileSystemLoadRTIM("RTIM_"+string(arrFlags[5]), "Textures");
                        
                        //Only do a partial redraw when the vram isn't already being totally redrawn.
                        conRenderer.psxVramPartialRedraw = (true &amp; (!conRenderer.psxVramRedraw));
                    }
                    
                    //Music
                    if(arrFlags[6] != $FF)
                    {
                        MusicQueueAdd(SEQIDToStreamID(arrFlags[6]), true);
                    }
                }
                
            }
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Objects

for(var i = 0; i &lt; ds_list_size(objectInstance); ++i)
{
    //Get Object Instance from List
    var arrObjInst = objectInstance[| i];
    
    //If this object instance is not enabled, skip it.
    if(!arrObjInst[ObjectInstance.IsEnabled])
        continue;
        
    //Calculate the distance between the player and the object  (XYZ)
    var distanceXYZ = point_distance_3d(arrObjInst[5], arrObjInst[6], arrObjInst[7], objPlayer.posX, objPlayer.posY, objPlayer.posZ);
    
    //Calculate object visibility based on distance
    var objVisibility = (arrObjInst[ObjectInstance.Mesh] != null);
    objVisibility &amp;= (distanceXYZ &lt;= arrObjInst[ObjectInstance.VisibleDistance]);
    if(arrObjInst[ObjectInstance.Layer] == 1)
    {
        objVisibility &amp;= layer1Enabled;
    }else{
        objVisibility &amp;= layer2Enabled;
    }
    arrObjInst[@ ObjectInstance.IsVisible] = objVisibility;
    
    //Object State Machine
    switch(arrObjInst[ObjectInstance.ObjectType])
    {
        //Single Slide Up Door
        /**
         *  Instance Flags:
         *    0000  Is Door Open
         *    0001  Door Animation Timer
         *    0002  Is Locked
         *    0003  Key Item ID
         *    0004  Message ID (Wrong Key)
         *    0005  Message ID (Locked)
        **/
        case 2:
            var objFlags = arrObjInst[23];    
            var animComplete = MAMSequencerComplete(arrObjInst[17]);
            
            //Check if the last item 'picked' is this one.
            if(objPlayer.tracedObject == i &amp;&amp; objFlags[0] == false &amp;&amp; animComplete)
            {
                //Door is locked.
                if(objFlags[2] &amp;&amp; !ignorekeys)
                {
                    if(objFlags[5] != $FF)
                    {
                        UIQueueMessage(LanguageGetString("uiMessage", objFlags[5]));
                    }
                    break;
                }
                
                //Begin Opening Door
                MAMSequencerSetAnimationRate(arrObjInst[17], 0, false, false, 0.0105);
                SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.083);
                objFlags[@ 0] = true;
            }
                        
            //Close the door when the player is far enough away
            if(distanceXYZ &gt; 4 &amp;&amp; objFlags[0] == true &amp;&amp; animComplete)
            {
                MAMSequencerSetAnimationRate(arrObjInst[17], 0, false, true, 0.008);
                SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.09);
                objFlags[@ 0] = false;
            }
            
            //Update Collision Body Position &amp; MAMSequencer
            if(!animComplete)
            {
                var cBodies = arrObjInst[21];
                
                var yOff = 0.78 + (1.56 * max(MAMSequencerPercentComplete(arrObjInst[17])-0.45, 0) * 1.815);
                CollisionBodySetTranslation(cBodies[0], arrObjInst[5], arrObjInst[6] + yOff, arrObjInst[7]);
                
                MAMSequencerUpdate(arrObjInst[17]);
            }
        break;
        
        //Double Slide Up Door
        /**
         *  Instance Flags:
         *    0000  Is Door Open
         *    0001  Door Animation Timer
         *    0002  Is Locked
         *    0003  Key Item ID
         *    0004  Message ID (Wrong Key)
         *    0005  Message ID (Locked)
        **/
        case 3:
            var objFlags = arrObjInst[23];    
            var animComplete = MAMSequencerComplete(arrObjInst[17]);
            
            //Check if the last item 'picked' is this one.
            if(objPlayer.tracedObject == i &amp;&amp; objFlags[0] == false &amp;&amp; animComplete)
            {
                //Door is locked.
                if(objFlags[2] &amp;&amp; !ignorekeys)
                {
                    if(objFlags[5] != $FF)
                    {
                        UIQueueMessage(LanguageGetString("uiMessage", objFlags[5]));
                    }
                    break;
                }
                
                //Begin Opening Door
                MAMSequencerSetAnimationRate(arrObjInst[17], 0, false, false, 0.007);
                SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.16);
                objFlags[@ 0] = true;
            }
                        
            //Close the door when the player is far enough away
            if(distanceXYZ &gt; 4 &amp;&amp; objFlags[0] == true &amp;&amp; animComplete)
            {
                MAMSequencerSetAnimationRate(arrObjInst[17], 0, false, true, 0.007);
                SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.16);
                objFlags[@ 0] = false;
            }
            
            //Update Collision Body Position &amp; MAMSequencer
            if(!animComplete)
            {
                var cBodies = arrObjInst[21];
                
                var yOff = 0.78 + (1.56 * MAMSequencerPercentComplete(arrObjInst[17]));
                CollisionBodySetTranslation(cBodies[0], arrObjInst[5], arrObjInst[6] + yOff, arrObjInst[7]);
                
                MAMSequencerUpdate(arrObjInst[17]);
            }
        break;
        
        //Double Door
        /**
         *  Instance Flags:
         *    0000  Linked Other Door
         *    0001  Is Door Open
         *    0002  Door Animation Timer
         *    0003  Is Locked
         *    0004  Key Object ID
         *    0005  Door #1 Rotation
         *    0006  Door #2 Rotation
        **/
        case 4:
            var arrClasses = conMain.fdatDB[0];
            
            var objFlags = arrObjInst[23];
            var objClass = arrClasses[arrObjInst[ObjectInstance.ClassID]];
            
            var arrObjInst2 = objectInstance[| objFlags[@ 0]];
            
            //Check if the last item 'picked' is this one.
            if(objPlayer.tracedObject == i &amp;&amp; objFlags[1] == false)
            {
                //Is this door locked?
                if(objFlags[3] &amp;&amp; !ignorekeys)
                {
                    UIQueueMessage(LanguageGetString("uiMessage", 2));
                    break;
                }
                
                //Stone or Wood?
                if(objClass[12] == 69)
                {
                    SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 5), 0.19); 
                }else{
                    SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.19);
                }
                
                //Set some flags
                objFlags[@ 1] = true;             
                objFlags[@ 2] = 0.0;
                
                objFlags[@ 5] = arrObjInst[@ 9];
                objFlags[@ 6] = arrObjInst2[@ 9];
            }
            
            //Get Colliders
            var objColliders = arrObjInst[@ ObjectInstance.CollisionBodies];
            
            //Opening Animation
            if(objFlags[1] == true)            //Door Open Animation
            {
                //Increment Animation Timer
                objFlags[@ 2] += (1/130) * global.DT;
                
                //While the timer is less than 1.0...
                if(objFlags[2] &lt; 1.0)
                {
                    //Interpolate Door Rotation.
                    arrObjInst[@ 9]  = objFlags[5] + smoothstep(0, -90, objFlags[2]);
                    arrObjInst2[@ 9] = objFlags[6] + smoothstep(0,  90, objFlags[2]);
                    
                    //BIG OOF - Surely this can be cleaner...
                    var cX = (lengthdir_x(0.88, objFlags[5]) + lengthdir_y(0.025, objFlags[5]));
                    var cY = (arrObjInst[6]+0.78)+(2.0*objFlags[@ 2]); 
                    var cZ = (lengthdir_y(0.88, objFlags[5]) - lengthdir_x(0.025, objFlags[5]));                  
                    cX = (arrObjInst[5] + cX) + lengthdir_x(objFlags[2], objFlags[5]-90);
                    cZ = (arrObjInst[7] + cZ) + lengthdir_y(objFlags[2], objFlags[5]-90)                    
                    CollisionBodySetTranslation(arrObjInst[21], cX, cY, cZ);
                    
                    //Build a new transformation matrices for obj1 and obj2
                    arrObjInst[@ 4] = 
                        matrix_build(
                            arrObjInst[5],  arrObjInst[6],  arrObjInst[7], 
                            arrObjInst[8],  arrObjInst[9],  arrObjInst[10], 
                            arrObjInst[11], arrObjInst[12], arrObjInst[13]
                        );
                        
                    arrObjInst2[@ 4] = 
                        matrix_build(
                            arrObjInst2[5],  arrObjInst2[6],  arrObjInst2[7], 
                            arrObjInst2[8],  arrObjInst2[9],  arrObjInst2[10], 
                            arrObjInst2[11], arrObjInst2[12], arrObjInst2[13]
                        );
                }else
                if(objFlags[@ 2] &gt; 2.0 &amp;&amp; distanceXYZ &gt; 2)    //When timer &gt; 2 and distance to door &gt; 5
                {
                    if(objClass[12] == 69)
                    {
                        SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 5), 0.19);
                    }else{
                        SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.19);
                    }
                    objFlags[@ 1] = false; 
                    objFlags[@ 2] = 1.0;   
                }
            }
            
            //Closing Animation
            if(objFlags[@ 1] == false)            //Door Close Animation
            {
                //While the timer is greater than 0
                if(objFlags[@ 2] &gt; 0.0)
                {
                    objFlags[@ 2] -= (1/130) * global.DT;
                    
                    arrObjInst[@ 9]  = objFlags[5] + smoothstep(0, -90, objFlags[2]);
                    arrObjInst2[@ 9] = objFlags[6] + smoothstep(0,  90, objFlags[2]);
                              
                    //MORE OOF     
                    var cX = (lengthdir_x(0.88, objFlags[@ 5]) + lengthdir_y(0.025, objFlags[@ 5]));
                    var cY = (arrObjInst[6]+0.78)+(2.0*objFlags[@ 2]); 
                    var cZ = (lengthdir_y(0.88, objFlags[@ 5]) - lengthdir_x(0.025, objFlags[@ 5]));                  
                    cX = (arrObjInst[5] + cX) + lengthdir_x(objFlags[@ 2], objFlags[@ 5]-90);
                    cZ = (arrObjInst[7] + cZ) + lengthdir_y(objFlags[@ 2], objFlags[@ 5]-90)                    
                    CollisionBodySetTranslation(arrObjInst[@ 21], cX, cY, cZ);

                    //Build a new transformation matrices for obj1 and obj2
                    arrObjInst[@ 4] = 
                        matrix_build(
                            arrObjInst[5],  arrObjInst[6],  arrObjInst[7], 
                            arrObjInst[8],  arrObjInst[9],  arrObjInst[10], 
                            arrObjInst[11], arrObjInst[12], arrObjInst[13]
                        );
                        
                    arrObjInst2[@ 4] = 
                        matrix_build(
                            arrObjInst2[5],  arrObjInst2[6],  arrObjInst2[7], 
                            arrObjInst2[8],  arrObjInst2[9],  arrObjInst2[10], 
                            arrObjInst2[11], arrObjInst2[12], arrObjInst2[13]
                        );
                }
            }
        break;
        
        //Secret Compartment
        /**
         *  Instance Flags:
         *    0000  Contained Object ID  
         *    0001  IsOpen?
         *    0002  IsEmpty?
        **/
        case 5:
            var objFlags = arrObjInst[ObjectInstance.Flags];
            
            //When the object is traced, begin opening the object.
            if(objPlayer.tracedObject == i &amp;&amp; objFlags[1] == false)
            {
                //Get the contained item
                if(objFlags[0] != null)
                {
                    //Set contained object to visible.
                    var containedItem = objectInstance[| objFlags[0]];
                    containedItem[@ 0] = true;
                    containedItem[@ 1] = true;
                    
                    show_debug_message(objFlags);
                }
                
                MAMSequencerSetAnimationRate(arrObjInst[17], 0, false, false, 0.009);
                SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.1);
                
                objFlags[@ 1] = true;
            }
            
            //Update animation until it is complete...
            if(objFlags[1] == true &amp;&amp; !MAMSequencerComplete(arrObjInst[17]))
            {
                //Update MAMSequencer.
                MAMSequencerUpdate(arrObjInst[17]);
            }
            
            //Second check for trace. We're looking to pickup this item this time.
            if(objPlayer.tracedObject == i &amp;&amp; objFlags[1] == true &amp;&amp; MAMSequencerComplete(arrObjInst[17]))
            {
                //Get the contained item
                var containedItem = objectInstance[| objFlags[0]];  
                    
                //Set Player LookItem
                if(objFlags[0] != null)
                {
                    containedItem[@ 0] = false;
                    containedItem[@ 1] = false;
                    
                    objPlayer.lookItemContainer = arrObjInst;
                    objPlayer.lookItemInst = containedItem;
                    objPlayer.lookItemMesh = containedItem[ObjectInstance.Mesh];
                    objPlayer.lookItemID   = containedItem[ObjectInstance.ClassID];
                    objPlayer.lookPosX = containedItem[ObjectInstance.PositionX];
                    objPlayer.lookPosY = containedItem[ObjectInstance.PositionY];
                    objPlayer.lookPosZ = containedItem[ObjectInstance.PositionZ];
                    objPlayer.lookRotX = containedItem[ObjectInstance.RotationX];
                    objPlayer.lookRotY = containedItem[ObjectInstance.RotationY];
                    objPlayer.lookRotZ = containedItem[ObjectInstance.RotationZ];
                    
                    PlayerSetState(PlayerState.LookItem);      
                }else{
                    //Display 'It's Empty' Message
                    UIQueueMessage(LanguageGetString("uiMessage", 6));   
                }
            }
        break;
               
        //Container
        case 9:
            var objFlags = arrObjInst[ObjectInstance.Flags];
            
            //When object is traced and is not empty...
            if(objPlayer.tracedObject == i)
            {
                //Get the contained item
                if(objFlags[0] != null)
                {
                    var containedItem = objectInstance[| objFlags[0]];  
                    
                    //Set player look item
                    objPlayer.lookItemContainer = arrObjInst;
                    objPlayer.lookItemInst = containedItem;
                    objPlayer.lookItemMesh = containedItem[ObjectInstance.Mesh];
                    objPlayer.lookItemID   = containedItem[ObjectInstance.ClassID];
                    objPlayer.lookPosX = containedItem[ObjectInstance.PositionX];
                    objPlayer.lookPosY = containedItem[ObjectInstance.PositionY];
                    objPlayer.lookPosZ = containedItem[ObjectInstance.PositionZ];
                    objPlayer.lookRotX = containedItem[ObjectInstance.RotationX];
                    objPlayer.lookRotY = containedItem[ObjectInstance.RotationY];
                    objPlayer.lookRotZ = containedItem[ObjectInstance.RotationZ];
                    
                    //Set player state to LookItem...
                    PlayerSetState(PlayerState.LookItem);                                
                }else{
                    UIQueueMessage(LanguageGetString("uiMessage", objFlags[1]));  
                }
            }
        break;
         
        //Sign
        case 13:
            if(objPlayer.tracedObject == i)
            {
                //Get Flags of Object
                var objFlags = arrObjInst[ObjectInstance.Flags];
                
                var signText = LanguageGetString("worldMessage", objFlags[0]);
                
                //Create UI
                var textUI = UIInstantiate(uiText);
                ds_list_add(textUI.textData, signText);
                
                GameStateSet(GameState.Menu);
            }
        break;
        
        //Item
        case 64:
            //Check to see if the last interacted object was this...
            if(objPlayer.tracedObject == i)
            {
                arrObjInst[@ 0] = false;
                arrObjInst[@ 1] = false;
                
                objPlayer.lookItemInst = objectInstance[| i];
                objPlayer.lookItemMesh = arrObjInst[ObjectInstance.Mesh];
                objPlayer.lookItemID   = arrObjInst[ObjectInstance.ClassID];
                objPlayer.lookPosX = arrObjInst[ObjectInstance.PositionX];
                objPlayer.lookPosY = arrObjInst[ObjectInstance.PositionY];
                objPlayer.lookPosZ = arrObjInst[ObjectInstance.PositionZ];
                objPlayer.lookRotX = arrObjInst[ObjectInstance.RotationX];
                objPlayer.lookRotY = arrObjInst[ObjectInstance.RotationY];
                objPlayer.lookRotZ = arrObjInst[ObjectInstance.RotationZ];
                PlayerSetState(PlayerState.LookItem);
            }
        break;
        
        //Floor Trap
        case 84:
            //Get the flags from the floor trap...
            var objFlags = arrObjInst[ObjectInstance.Flags]; 
            
            //If it's already open, we don't do anything.
            if(objFlags[0] == false)
            {
                //Get trigger
                var trigger = triggerInstance[| objFlags[1]];
                
                //Check for trigger entry by the user (maybe KF has a flag for below/above?)
                if(TriggerInstanceOnEnter(trigger))
                {
                    MAMSequencerSetAnimationRate(arrObjInst[ObjectInstance.MAMSequencer], 0, false, false, 0.08);
                    SoundPlay2DFrequency(WBFGetWave(objFlags[2], 2),  8000);   //Play 'Thunk' Sound                 
                    SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.32);   //Play Stone Sliding
                    
                    objFlags[@ 0] = true;   //Set 'IsOpen' flag...
                }    
            }

            MAMSequencerUpdate(arrObjInst[ObjectInstance.MAMSequencer]);
        break;
        
        //Generic
        case 255:
            //Check to see if the last interacted object was this...
            if(objPlayer.tracedObject == i)
            {
                //Get Object Flags
                var arrFlags = arrObjInst[ObjectInstance.Flags];
                
                //Queue message...
                if(arrFlags[0] != null)
                    UIQueueMessage(LanguageGetString("uiMessage", arrFlags[0]));
            }
        break;
        
    }
}


/*
for(var i = 0; i &lt; ds_list_size(objectInstance); ++i)
{
    var objInst = objectInstance[| i];
    
    //When object instance is disabled, we skip it.
    if(objInst[0] == false)
        continue;
        
    //We need to use distance a lot in these functions, so we always calculate it...
    //It's used for calculating visibility anyway.
    var objDist = point_distance(objInst[5], objInst[7], conRenderer.camXfrom, conRenderer.camZfrom);
    
    //
    // Calculate Visibility
    //
    var objVisible = (objInst[16] != null);
    objVisible &amp;= objDist &lt; 10;    
    objInst[@ 1] = objVisible;
    
    //
    // Object State Machine
    //
    var objInst  = objectInstance[| i];
    var objClass = arrObjectClasses[objInst[2]];
    
    //Switch based on 'ObjectType' value of class.
    switch(objClass[0])
    {        
        //Traps
        case 81:
            if(!objVisible)
                break;
                
            MAMSequencerUpdate(objInst[17]);
        break;

         //Secret Compartment
        case 5:
            if(!objVisible)
                break;
                
            var objFlags = objInst[23];
            
            //Get Distance to Door
            if(objDist &lt; 2)
            {
                //See if the player is interacting with this door...
                if(InputManagerGetPressed(InputMap.Activate) &amp;&amp; objFlags[0] == false)
                {
                    MAMSequencerSetAnimationRate(objInst[17], 0, false, false, 0.005);
                    SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.19);
                    objFlags[@ 0] = true;
                }
            }   
            
            //Update the MAMSequencer when visible
            MAMSequencerUpdate(objInst[17]);                  
        break;
        
        //Container (Barrel/Bones etc)
        case 9:
            if(!objVisible)
                break;
                
            var objFlags = objInst[23];
                
            //Check if the last item 'picked' is this one.
            if(conRenderer.lastPickedObject == i)
            {
                //Check if the object wanted actually exists...
                if(objFlags[0] &gt; 0)
                {
                    //Get the 'contained' object
                    var subObject = objectInstance[| objFlags[0]];
                    
                    //Add the subobject to the player inventory. 
                    InventoryAddItem(objPlayer.inventory, subObject[2], 1);
                    
                    //Remove subobject from the flags.
                    objFlags[@ 0] = null;
                }else{
                    //Nothing is in the container, so tell that to the player.
                    UIQueueMessage(LanguageGetString("uiMessage", 5));
                }
            }
        break;
        
        //Generic Objects
        case 255:
            if(!objVisible)
                break;
                
            //Check if this was our last interacted with object
            if(conRenderer.lastPickedObject == i)
            {
                //Switch based on object class
                switch(objInst[2])
                {
                    case 163:
                        UIQueueMessage(LanguageGetString("uiMessage", 30));
                    break;
                }   
            }    
        break;
    }
}
*/

///SoundPlay2DPitch(WBFGetWave(conMain.gameSound, 6), 0.10); - STONE DOOR SOUND!!! :3
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Effects

for(var i = 0; i &lt; ds_list_size(effectInstance); ++i)
{
    var arrEffectInst = effectInstance[| i];
    var arrEffectData = arrEffectInst[EffectInstance.Data];
    
    switch(arrEffectInst[EffectInstance.Type])
    {
        //Flame
        case 1:
            ParticleSystemStep(arrEffectData[0]);      
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Instantiate Map Data

//Load Map Instances
MapLoadObjects();
MapLoadEffects();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Map Collisions

/*

//Sniff for info on collision packets...
for(var i = 0; i &lt; 256; ++i)
{
    if(MAP1DecodeCollisionPacket(cBuffer, i) == null)
    {
        break;
    }
}

*/

//Build Map Collisions
var CMesh = buffer_create(1024, buffer_grow, 1);
buffer_seek(CMesh, buffer_seek_start, 0);

for(var i = 0; i &lt; 80; ++i)
{
    for(var j = 0; j &lt; 80; ++j)
    {
        //Get tile from tilemap
        var arrTile = tilemap[i, j];
        
        //Add Collisions for Layer1
        //MAP1DecodeCollisionPacket(cBuffer, arrTile[3], CMesh, arrTile[2], arrTile[1], i, j);
        MAP1DecodeCollisionPacket(cBuffer, arrTile[8], CMesh, arrTile[7], arrTile[6], i, j);
    }   
}

//Create Collision shit
var cShape = CollisionShapeCreateTrimesh(CMesh, 3, (buffer_tell(CMesh) / 36));
var cBody  = CollisionBodyCreate(cShape);
CollisionWorldAddBody(cBody, CMask.Static, CMask.Player);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set Ready Flag

ready = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Is Map Ready?

if(!ready)
    exit;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Skyboxes

//Set Draw State for Skyboxes
d3d_set_zwriteenable(false);

shader_set(shdMSM);

for(var i = 0; i &lt; ds_list_size(skyboxInstance); ++i)
{
    //Get Skybox Instance
    var arrSkyboxInstance = skyboxInstance[| i];
    
    //Make sure the skybox is visible
    if(!arrSkyboxInstance[1])
        continue;
        
    //Skybox State Enable
    d3d_transform_set_identity();
    switch(arrSkyboxInstance[2])
    {
        case 248:   //Moon
            draw_set_blend_mode(bm_add);
        default:    //Nighttime Sky
            d3d_transform_add_scaling(2.75, 2.75, 2.75); 
        break;
        
        case 245:   //Mountain
            draw_set_blend_mode(bm_add);
        case 244:   //Daytime Sky
        break;
    }    
    d3d_transform_add_translation(conRenderer.camXfrom, conRenderer.camYfrom, conRenderer.camZfrom);
    
    //Draw Skybox
    MAMDraw(arrSkyboxInstance[3], null);
    
    //Reset blendmode
    draw_set_blend_mode(bm_normal);
}

//Reset draw state
d3d_set_zwriteenable(true);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Map Tilemap (Opaque)

shader_set(shdMSMClipAlpha);
SetCullMode(CullMode.Front);

var tx, ty;
for(var i = -11; i &lt;= 11; ++i)
{
    tx = floor(objPlayer.posX + i);
    
    if(tx &lt; 0 || tx &gt; 79)
        continue;
    
    for(var j = -11; j &lt;= 11; ++j)
    {
        ty = floor(objPlayer.posZ + j);
        
        if(ty &lt; 0 || ty &gt; 79)
            continue;
          
        var arrTile = tilemap[tx, ty];
        
        //Draw Layer 1
        if(arrTile[0] &lt; array_length_1d(tileset))
        {
            matrix_set(matrix_world, arrTile[11]);
            MSMDrawMesh(tileset, arrTile[0]);
        } 
        
        //Draw Layer 2
        if(arrTile[5] &lt; array_length_1d(tileset))
        {
            matrix_set(matrix_world, arrTile[12]);
            MSMDrawMesh(tileset, arrTile[5]);
        } 
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Effects

/*
d3d_transform_set_identity();
shader_reset();

for(var i = 0; i &lt; ds_list_size(effectInstance); ++i)
{
    var arrEffectInst = effectInstance[| i];
    var arrEffectData = arrEffectInst[EffectInstance.Data];
    
    //Set Transform
    d3d_transform_set_translation(arrEffectInst[EffectInstance.PositionX], arrEffectInst[EffectInstance.PositionY], arrEffectInst[EffectInstance.PositionZ]);
    
    switch(arrEffectInst[EffectInstance.Type])
    {
        //Flame
        case 1:
            draw_set_blend_mode(bm_add);
            ParticleSystemDraw(arrEffectData[0]);
            draw_set_blend_mode(bm_normal);
        break;
    }
}

texture_set_stage(0, conRenderer.psxVramTexture);
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Object

d3d_transform_set_identity();
SetCullMode(CullMode.None);
shader_set(shdMSM);

for(var i = 0; i &lt; ds_list_size(objectInstance); ++i)
{
    var arrObjInst = objectInstance[| i];

    //Don't draw when object is invisible.
    if(arrObjInst[ObjectInstance.IsVisible] == false)
        continue;
        
    //Draw Object By Type
    switch(arrObjInst[ObjectInstance.ObjectType])
    {          
        case 13:
            //Set Draw Params   
            if(arrObjInst[2] != 158 &amp;&amp; arrObjInst[2] != 159 &amp;&amp; arrObjInst[2] != 165)
                draw_set_blend_mode(bm_add);            //Also makes signs more visible. We only do this for the scibbles.
                
            matrix_set(matrix_world, arrObjInst[4]);
            MAMDraw(arrObjInst[16], null); 
                    
            //Reset Draw Params
            draw_set_blend_mode(bm_normal);
        break;
        
        case 64:
            //Some Items are drawn with ZBuffering turned off
            //This is most definately a stinky hack.
            switch(arrObjInst[ObjectInstance.ClassID])
            {
                //case 71:    //BloodStone
                case 73:    //Verdite
                case 76:    //Dragon Crystal
                case 77:    //Blue Potion
                case 78:    //Pink Potion
                case 79:    //Green Potion
                case 80:    //Gold Potion
                case 82:    //Crystal Flask
                case 83:    //Figure of Seath
                case 90:    //Fire Crystal
                case 91:    //Water Crystal
                case 92:    //Earth Crystal
                case 93:    //Wind Crystal
                case 94:    //Light Crystal
                case 96:    //Crystal
                case 97:    //Crystal Shard
                    d3d_set_zwriteenable(false);
                break;
            }    
            matrix_set(matrix_world, arrObjInst[4]);            
            MAMDraw(arrObjInst[16], null); 
            
            d3d_set_zwriteenable(true);
        break;
        
        //Floor Trap.. Drawn differently if it is open.
        case 84:
        
            //Get Object Flags
            var objFlags = arrObjInst[ObjectInstance.Flags];
            
            //Set Transformation Matrix
            matrix_set(matrix_world, arrObjInst[4]);
            
            //Draw, dependant on flags...
            if(objFlags[0] == true)
            {
                MAMDraw(arrObjInst[16], arrObjInst[17]);
            }else{
                MAMDraw(arrObjInst[16], null); 
            }    
        break;
        
        default:
            matrix_set(matrix_world, arrObjInst[4]);
            SetCullMode(CullMode.Front);
                MAMDraw(arrObjInst[16], arrObjInst[17]);    
            SetCullMode(CullMode.None);        
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Player Held Item

// I hate that this has to be in the map draw, but fuck it.

//When the player is looking at an item, draw it.
if(objPlayer.lookItemMesh != null)
{
    //Some Items are drawn with ZBuffering turned off
    //This is most definately a stinky hack.
    switch(objPlayer.lookItemID)
    {
        //case 71:    //BloodStone
        case 73:    //Verdite
        case 76:    //Dragon Crystal
        case 77:    //Blue Potion
        case 78:    //Pink Potion
        case 79:    //Green Potion
        case 80:    //Gold Potion
        case 82:    //Crystal Flask
        case 83:    //Figure of Seath
        case 90:    //Fire Crystal
        case 91:    //Water Crystal
        case 92:    //Earth Crystal
        case 93:    //Wind Crystal
        case 94:    //Light Crystal
        case 96:    //Crystal
        case 97:    //Crystal Shard
            d3d_set_zwriteenable(false);
            d3d_set_culling(false);
        break;
    }    

    //Set Transform for 'LookItem'
    d3d_transform_set_identity();
    
    //Calculating rotation for the held item
    var pDir = point_direction(objPlayer.posX, objPlayer.posZ, objPlayer.lookPosX, objPlayer.lookPosZ)-90;
    
    d3d_transform_add_rotation_axis(0, 1, 0, objPlayer.lookRotY);
    d3d_transform_add_rotation_axis(dcos(pDir), 0, dsin(pDir), -objPlayer.lookRotX);

    d3d_transform_add_scaling(-1, 1, 1);
    d3d_transform_add_translation(objPlayer.lookPosX, objPlayer.lookPosY, objPlayer.lookPosZ);
    
    //Draw Look Item  
    MAMDraw(objPlayer.lookItemMesh, null);    

    d3d_set_zwriteenable(true);
}    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Triggers (Debug)

shader_reset();
d3d_transform_set_identity();

if(debug == true &amp;&amp; false == false)
{
    for(var i = 0; i &lt; ds_list_size(triggerInstance); ++i)
    {
        TriggerInstanceDebugDraw(triggerInstance[| i]);   
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///End Draw

//Reset Transformation
d3d_transform_set_identity();

//Reset Rendering
shader_set_uniform_f(shader_get_uniform(shdMSM, "uAlpha"), 1.0);
shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
